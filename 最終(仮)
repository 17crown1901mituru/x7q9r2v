// ==UserScript==
// @name         Tantora_SubGateway_Integrated_Final
// @namespace    http://oitsuru.net/
// @version      1.2
// @description  抗争セッション管理＋事前/ファイナルスキャン＋突入制御＋ロギング完全版
// @match        *://tantora.jp/*
// @grant        none
// @run-at       document-start
// ==/UserScript==

(function() {
    'use strict';

    /**************************************************
     *  共通キー（Viewer / 攻撃スクリプトと完全互換）
     **************************************************/
    const KEYS = {
        WAR_SESSIONS: 'tantora_session_store',
        SYS_SESSIONS: 'tantora_system_store',
        ACTIVE_ID: 'tantora_active_session_id',
        ACTIVE_TID: 'active_war_tid',
        STRATEGY: 'strategy_',
        FINAL: 'strategy_',
        FINAL_DONE: 'war_final_adjust_done',
        ATTACK_KILL: 'tantora_attack_kill_flag'
    };

    /**************************************************
     *  内部状態
     **************************************************/
    let isPreScanning = false;
    let isFinalScanning = false;
    let isEnteringWar = false;
    let finalScanTimer = null;
    let warEntryTimer = null;

    const now = () => new Date();
    const logTime = () => now().toLocaleTimeString('ja-JP');

    /**************************************************
     *  ログ保存（Viewer互換）
     **************************************************/
    const pushWarLog = (type, data) => {
        const sid = localStorage.getItem(KEYS.ACTIVE_ID);
        if (!sid) return;

        let store = {};
        try { store = JSON.parse(localStorage.getItem(KEYS.WAR_SESSIONS) || "{}"); }
        catch(e){ store = {}; }

        if (!store[sid]) {
            const tid = localStorage.getItem(KEYS.ACTIVE_TID) || "0";
            store[sid] = {
                info: { tid, start: "不明", enemy: "不明" },
                logs: []
            };
        }

        store[sid].logs.push({
            t: logTime(),
            type,
            d: data
        });

        if (store[sid].logs.length > 200) store[sid].logs.shift();
        localStorage.setItem(KEYS.WAR_SESSIONS, JSON.stringify(store));
    };

    /**************************************************
     *  抗争勃発!!リンク解析
     **************************************************/
function parseWarLink(html) {
        const reg = /team_id=(\d+)[^>]*>([^<]+?)と抗争勃発!!<br\s*\/?>(\d{2}\/\d{2}\s\d{2}時\d{2}分)開戦/;
        const m = html.match(reg);
        if (!m) return null;

        return {
            tid: m[1],
            enemy: m[2].trim(),
            startStr: m[3]
        };
    }

    function parseWarDate(startStr) {
        const m = startStr.match(/(\d{2})\/(\d{2})\s(\d{2})時(\d{2})分/);
        if (!m) return null;
        const y = now().getFullYear();
        return new Date(y, m[1]-1, m[2], m[3], m[4]);
    }

    function buildSessionId(tid, startStr) {
        const compact = startStr.replace(/[^\d]/g, '').slice(0, 8);
        return `${tid}_${compact}`;
    }

    function isSameSession(existingSid, tid, startStr) {
        if (!existingSid) return false;
        const parts = existingSid.split('_');
        const sidTid = parts[0];
        const sidTime = parts[1];
        const newTime = startStr.replace(/[^\d]/g, '').slice(0, 8);
        return sidTid === tid && sidTime === newTime;
    }


const ROLE_SEQ_MAP = {
  "総長": 100,
  "副総長": 101,
  "親衛隊長": 102,
  "護衛隊長": 103,
  "特攻隊長": 104,
  "ケツ持ち": 105,
  "旗持ち": 106,
  "幹部": [107, 108, 109]  // 幹部は複数
};
/**************************************************
 *  事前スキャン（役職対応＋一般メンバー対応 完全統合版）
 **************************************************/
async function scan(tid, enemy, startStr) {

    // pre があるかどうかで分岐
    const preJson = localStorage.getItem(`${KEYS.STRATEGY}${tid}`);
    const pre = preJson ? JSON.parse(preJson) : null;

    // 画面総数（公式）
    const total = await getTotalCount(tid);

    // forwardScan（実際に読み込んだID）
    let current = await forwardScan(tid, total);

    // 総数チェック（初回・差分共通）
    if (current.length !== total) {
        pushWarLog("ERROR", {
            where: "scan",
            detail: `総数不一致 page=${total} scanned=${current.length}`
        });
        // ここで return しないのは最低限のデータ生成のため
    }

    /**********************************************
     * ① 初回スキャン（pre が無い）
     **********************************************/
    if (!pre) {

        // seq 初回付与
        assignSeq(current);

        // 欠番検出
        const missing = detectMissingSeq(current);

        // 欠番補正
        if (missing.length > 0) {
            current = await fixMissingSeq(tid, current, missing);
        }

        // 重複排除
        current = mergeMembers(current);

        // 整合性チェック（一般のみ）
        const integrity = validateSeqIntegrity(current);

        // 保存（pre データ）
        savePreScanResult(tid, enemy, startStr, current);

        // ログ
        logPreScanSummary(tid, total, current, missing, integrity);

        // 初回はここで終了（finalScan が後で呼ばれる）
        return current;
    }

    /**********************************************
     * ② 差分スキャン（pre がある）
     **********************************************/
    const preMap = new Map(pre.map(m => [m.id, m]));

    // pre の最大 seq を取得（欠番あってもOK）
    let maxSeq = 0;
    for (const m of pre) {
        if (typeof m.seq === "number" && m.seq > maxSeq) {
            maxSeq = m.seq;
        }
    }
    let nextSeq = maxSeq + 1;

    const merged = [];

    for (const m of current) {
        if (preMap.has(m.id)) {
            // 残留 → pre の seq/g をそのまま使う
            merged.push(preMap.get(m.id));
        } else {
            // 新規加入 → seq/g を付与
            merged.push({
                id: m.id,
                name: m.name,
                lv: m.lv,
                g: decideGTag(m.lv),
                role: m.role ?? null,
                seq: nextSeq++
            });
        }
    }

    // 脱退は merged に入らないだけでOK

    /**********************************************
     * C/D 統合（ファイナルアドジャスト）
     **********************************************/
    const adjusted = finalAdjustGroup(merged);

    /**********************************************
     * 攻撃用データ生成（groups + seqToId）
     **********************************************/
    const attackData = buildAttackData(adjusted);

    /**********************************************
     * 保存（確定データ＋攻撃用データ）
     **********************************************/
    localStorage.setItem(`${KEYS.STRATEGY}${tid}_final`, JSON.stringify(adjusted));
    localStorage.setItem(`${KEYS.STRATEGY}${tid}_attackData`, JSON.stringify(attackData));

    // ロックフラグ
    const sid = localStorage.getItem(KEYS.ACTIVE_ID);
    if (sid) {
        localStorage.setItem(KEYS.FINAL_DONE, sid);
    }

    pushWarLog("STRATEGY_LOCKED", {
        res: "ファイナルアドジャスト完了（確定データロック）",
        count: adjusted.length
    });

    return adjusted;
}

/**************************************************
 *  ページ総数取得
 **************************************************/
async function getTotalCount(tid) {
    const url = `https://tantora.jp/team/member-list?team_id=${tid}`;
    try {
        const html = await fetch(url).then(r => r.text());
        const m = html.match(/全(\d+)件中/);
        return m ? Number(m[1]) : 0;
    } catch (e) {
        pushWarLog("ERROR", { where: "getTotalCount", detail: e.toString() });
        return 0;
    }
}

/**************************************************
 *  順方向スキャン（役職＋一般）
 **************************************************/
async function forwardScan(tid, total) {
    const baseUrl = `https://tantora.jp/team/member-list?team_id=${tid}`;
    const pages = Math.ceil(total / 5);
    const sleep = ms => new Promise(r => setTimeout(r, ms));

    let roleMembers = [];
    let generalMembers = [];

    for (let p = 1; p <= pages; p++) {
        const url = p === 1 ? baseUrl : `${baseUrl}&page=${p}`;
        const html = await fetchPageHtml(url);

        const blocks = splitMemberBlocks(html);

        for (const block of blocks) {
            const roleName = extractRoleName(block); // 総長/副総長/幹部/…/null
            const id = extractId(block);
            const name = extractName(block);
            const lv = extractLv(block);
            const g = decideGTag(lv);

            if (!id || !name || !lv) continue;

            if (roleName) {
                // 役職者
                roleMembers.push({
                    id, name, lv, g,
                    role: roleName,
                    seq: null,
                    fixStage: 0,
                    fixReason: null
                });
            } else {
                // 一般メンバー
                generalMembers.push({
                    id, name, lv, g,
                    role: null,
                    seq: null,
                    fixStage: 0,
                    fixReason: null
                });
            }
        }

        await sleep(400);
    }

    return [...roleMembers, ...generalMembers];
}

/**************************************************
 *  HTML取得
 **************************************************/
async function fetchPageHtml(url) {
    try {
        return await fetch(url).then(r => r.text());
    } catch (e) {
        pushWarLog("ERROR", { where: "fetchPageHtml", detail: e.toString() });
        return "";
    }
}

/**************************************************
 *  メンバーブロック抽出
 **************************************************/
function splitMemberBlocks(html) {
    const blocks = [];
    const re = /<div class="common-info-bg[12]">([\s\S]*?)<\/div>/g;
    let m;
    while ((m = re.exec(html)) !== null) {
        blocks.push(m[1]);
    }
    return blocks;
}

/**************************************************
 *  役職名抽出
 **************************************************/
function extractRoleName(block) {
    const m = block.match(/<span[^>]*color:\s*#ff0a00[^>]*>([^<]+)<\/span>/);
    return m ? m[1].trim() : null;
}

/**************************************************
 *  ID / 名前 / LV 抽出
 **************************************************/
function extractId(block) {
    const m = block.match(/other_id=(\d+)/);
    return m ? m[1] : null;
}

function extractName(block) {
    const m = block.match(/player\?other_id=\d+">([^<]+)<\/a>/);
    return m ? decodeHtml(m[1].trim()) : null;
}

function extractLv(block) {
    const m = block.match(/LV:(\d+)/);
    return m ? parseInt(m[1]) : null;
}

/**************************************************
 *  gタグ決定（暫定）
 **************************************************/
function decideGTag(lv) {
    if (lv >= 2000) return 'A';
    if (lv >= 1500) return 'B';
    if (lv >= 1000) return 'C';
    return 'D';
}

function decodeHtml(str) {
    return str
        .replace(/&amp;/g, '&')
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&#39;/g, "'")
        .replace(/&quot;/g, '"');
}

/**************************************************
 *  seq 付与（役職は役職名、一般は1〜N）
 **************************************************/
function assignSeq(members) {
    let generalSeq = 1;              // 一般は 1〜50
    let kanbuIndex = 0;              // 幹部の順番管理

    for (const m of members) {

        // 一般メンバー
        if (!m.role) {
            m.seq = generalSeq++;
            continue;
        }

        // 幹部（複数）
        if (m.role === "幹部") {
            const seq = ROLE_SEQ_MAP["幹部"][kanbuIndex++];
            m.seq = seq ?? null;     // 4人目以降は null でも弾いてもOK
            continue;
        }

        // 単一役職（総長〜旗持ち）
        const seq = ROLE_SEQ_MAP[m.role];
        m.seq = seq ?? null;         // 未定義の役職なら null
    }
}

/**************************************************
 *  欠番検出（一般のみ）
 **************************************************/
function detectMissingSeq(members) {
    const seqSet = new Set(
        members.filter(m => !m.role).map(m => m.seq)
    );

    const maxSeq = Math.max(...seqSet, 0);
    const missing = [];

    for (let i = 1; i <= maxSeq; i++) {
        if (!seqSet.has(i)) missing.push(i);
    }

    return missing;
}

/**************************************************
 *  欠番補正（一般のみ）
 **************************************************/
async function fixMissingSeq(tid, members, missingSeq) {
    const manual = [];

    for (const seq of missingSeq) {
        const r1 = await tryFixSeq(tid, seq, 1);
        if (r1.success) {
            members.push(r1.member);
            continue;
        }

        const r2 = await tryFixSeq(tid, seq, 2);
        if (r2.success) {
            members.push(r2.member);
            continue;
        }

        manual.push(seq);
    }

    for (const seq of manual) {
        const m = await manualFixSeq(seq);
        if (m) members.push(m);
    }

    return members;
}

/**************************************************
 *  seq→ページ変換
 **************************************************/
function calcPageFromSeq(seq) {
    return {
        page: Math.ceil(seq / 5),
        index: (seq - 1) % 5
    };
}

/**************************************************
 *  欠番補正（1回目/2回目）
 **************************************************/
async function tryFixSeq(tid, seq, attempt) {
    const { page, index } = calcPageFromSeq(seq);
    const baseUrl = `https://tantora.jp/team/member-list?team_id=${tid}`;
    const url = page === 1 ? baseUrl : `${baseUrl}&page=${page}`;

    const html = await fetchPageHtml(url);
    const blocks = splitMemberBlocks(html);

    if (!blocks[index]) return { success: false };

    const block = blocks[index];
    const id = extractId(block);
    const name = extractName(block);
    const lv = extractLv(block);
    const g = decideGTag(lv);

    if (!id || !name || !lv) return { success: false };

    return {
        success: true,
        member: {
            id, name, lv, g,
            role: null,
            seq,
            tag: `${seq}${"'".repeat(attempt)}${g}`,
            fixStage: attempt,
            fixReason: "OK"
        }
    };
}

/**************************************************
 *  手動補正
 **************************************************/
async function manualFixSeq(seq) {
    const url = prompt(`${seq} のメンバーを取得できませんでした。\nプロフィールURLを入力してください。`);
    if (!url) return null;

    const id = url.match(/other_id=(\d+)/)?.[1];
    if (!id) return null;

    return {
        id,
        name: "UNKNOWN",
        lv: 0,
        g: "D",
        role: null,
        seq,
        tag: `${seq}'''D`,
        fixStage: 3,
        fixReason: "MANUAL"
    };
}

/**************************************************
 *  重複排除
 **************************************************/
function mergeMembers(members) {
    return [...new Map(members.map(m => [m.id, m])).values()];
}

/**************************************************
 *  整合性チェック（一般のみ）
 **************************************************/
function validateSeqIntegrity(members) {
    const seqSet = new Set(
        members.filter(m => !m.role).map(m => m.seq)
    );

    const maxSeq = Math.max(...seqSet, 0);
    const missing = [];

    for (let i = 1; i <= maxSeq; i++) {
        if (!seqSet.has(i)) missing.push(i);
    }

    return missing.length === 0;
}



/**************************************************
 *  保存
 **************************************************/
function savePreScanResult(tid, enemy, startStr, members) {
    localStorage.setItem(`${KEYS.STRATEGY}${tid}`, JSON.stringify(members));

    const sid = buildSessionId(tid, startStr);
    localStorage.setItem(KEYS.ACTIVE_ID, sid);
    localStorage.setItem(KEYS.ACTIVE_TID, tid);

    let store = {};
    try { store = JSON.parse(localStorage.getItem(KEYS.WAR_SESSIONS) || "{}"); }
    catch(e){ store = {}; }

    if (!store[sid]) {
        store[sid] = {
            info: { tid, start: startStr, enemy },
            logs: []
        };
    }

    localStorage.setItem(KEYS.WAR_SESSIONS, JSON.stringify(store));
}

/**************************************************
 *  ログ
 **************************************************/
function logPreScanSummary(tid, total, members, missing, integrity) {
    pushWarLog("SCAN_COMPLETE", {
        tid,
        total,
        count: members.length,
        missing,
        integrity
    });
}

/**************************************************
 *  ファイナルスキャン（初回 or 差分スキャン → 突入準備）
 **************************************************/
async function finalScan(tid, enemy, startStr) {
    if (isFinalScanning) return;
    isFinalScanning = true;

    try {

        /**********************************************
         * 1. セッション一致確認
         **********************************************/
        const existingSid = localStorage.getItem(KEYS.ACTIVE_ID);
        const same = isSameSession(existingSid, tid, startStr);

        if (!same) {
            pushWarLog("INFO", {
                res: "別抗争検出 → 初回スキャンに戻る",
                oldSid: existingSid,
                newTid: tid,
                newStart: startStr
            });

            await scan(tid, enemy, startStr);
            return;
        }

        /**********************************************
         * 2. 通常のファイナルスキャン
         **********************************************/
        await scan(tid, enemy, startStr);

        /**********************************************
         * 3. 抗争突入準備へ移行
         **********************************************/
        scheduleWarEntry(tid, startStr);

    } catch (e) {
        pushWarLog("ERROR", { where: "finalScan", detail: e.toString() });

    } finally {
        isFinalScanning = false;
    }
}

/**************************************************
 *  ファイナルスキャン予約（/my* トリガー方式・統合版）
 **************************************************/
let __finalScanExecuted = false;

function scheduleFinalScan(tid, enemy, startStr) {
    const warDate = parseWarDate(startStr);
    if (!warDate) return;

    // 予約情報を保存
    const payload = {
        tid,
        enemy,
        startStr,
        warTime: warDate.getTime()
    };
    localStorage.setItem("tantora_final_schedule", JSON.stringify(payload));

    pushWarLog("INFO", {
        res: "ファイナルスキャン予約（/my* トリガー方式）",
        warTime: warDate.toLocaleString()
    });

    /**************************************************
     *  /my* に入ったときに実行する処理をここで定義
     **************************************************/
    document.addEventListener("DOMContentLoaded", async () => {
        if (!location.pathname.startsWith("/my")) return;

        const raw = localStorage.getItem("tantora_final_schedule");
        if (!raw) return;

        let info;
        try { info = JSON.parse(raw); } catch { return; }

        const { tid, enemy, startStr, warTime } = info;
        const now = Date.now();
        const fifteenMin = 15 * 60 * 1000;
        const twentySec = 20 * 1000;

        // 時間窓チェック
        if (now < warTime - fifteenMin) return;
        if (now > warTime - twentySec) return;

        // FINAL_DONE が一致していれば実行不要
        const sid = localStorage.getItem(KEYS.ACTIVE_ID);
        const done = localStorage.getItem(KEYS.FINAL_DONE);
        if (sid && done && sid === done) return;

        // 同一セッションで1回だけ
        if (__finalScanExecuted) return;
        __finalScanExecuted = true;

        pushWarLog("INFO", { res: "my* トリガー → ファイナルスキャン実行" });

        await finalScan(tid, enemy, startStr);
    });
}
/**************************************************
 *  抗争突入準備（開始2秒前から 400ms 間隔で突入）
 **************************************************/
function scheduleWarEntry(tid, startStr) {
    if (isEnteringWar) return;
    isEnteringWar = true;

    const warDate = parseWarDate(startStr);
    if (!warDate) {
        pushWarLog("ERROR", { where: "scheduleWarEntry", detail: "開始日時パース失敗" });
        return;
    }

    const targetTime = warDate.getTime() - 2000; // 開始2秒前

    const waitUntil2secBefore = () => {
        const nowTime = now().getTime();
        if (nowTime < targetTime) {
            // まだ早い → 500ms後に再チェック
            warEntryTimer = setTimeout(waitUntil2secBefore, 500);
            return;
        }
        // ここから突入リトライ開始
        tryEnterWar();
    };

    const tryEnterWar = () => {
        // すでに war/member-list に入れているか？
        if (location.pathname.includes("/war/member-list")) {
            pushWarLog("INFO", { res: "抗争画面突入成功 → ロギング開始" });
            startWarLogging();
            return;
        }

        // まだ入れていない → 400ms 間隔で突入を試みる
        location.href = `https://tantora.jp/war/member-list?team_id=${tid}`;
        warEntryTimer = setTimeout(tryEnterWar, 400);
    };

    pushWarLog("INFO", {
        res: "抗争突入準備開始",
        target: new Date(targetTime).toLocaleString()
    });

    waitUntil2secBefore();
}

/**************************************************
 *  fetch パッチ（裏側通信のみロギング）
 **************************************************/
function patchFetchForLogging() {
    if (window.__fetch_patched__) return; // 二重パッチ防止
    window.__fetch_patched__ = true;

    const originalFetch = window.fetch;

    window.fetch = async (...args) => {
        const res = await originalFetch(...args);

        try {
            const url = args[0]?.toString() || "";

            // 抗争関連通信のみログ対象
            if (url.includes("/war/")) {
                const clone = res.clone();
                clone.text().then(text => {
                    // 画面に表示される情報はログ対象外
                    // → ここでは裏側通信（レスポンス全文）を保存
                    pushWarLog("FETCH_RES", {
                        url,
                        res: text
                    });
                });
            }
        } catch (e) {
            pushWarLog("ERROR", { where: "fetchPatch", detail: e.toString() });
        }

        return res;
    };
}

/**************************************************
 *  抗争画面突入後のロギング開始
 **************************************************/
function startWarLogging() {
    pushWarLog("INFO", { res: "ロギングモード開始（抗争中）" });

    // fetch パッチを適用（1回だけ）
    patchFetchForLogging();

    // 抗争終了検知を定期実行
    setInterval(checkWarEnd, 3000);
}

/**************************************************
 *  抗争終了画面の終了日時を抽出
 *  例: 【抗争終了日時】11/09 20:11
 **************************************************/
function parseWarEndDate(html) {
    const m = html.match(/抗争終了日時】(\d{2})\/(\d{2})\s(\d{2}):(\d{2})/);
    if (!m) return null;

    const nowYear = now().getFullYear();
    const month = parseInt(m[1]);
    const day = parseInt(m[2]);
    const hour = parseInt(m[3]);
    const min = parseInt(m[4]);

    return new Date(nowYear, month - 1, day, hour, min);
}

/**************************************************
 *  開始日時と終了日時の整合性チェック
 *  0時跨ぎ・年跨ぎにも対応
 **************************************************/
function isSameWarSession(startDate, endDate) {
    if (!startDate || !endDate) return false;

    // 0時跨ぎ補正
    if (endDate < startDate) {
        endDate = new Date(
            endDate.getFullYear(),
            endDate.getMonth(),
            endDate.getDate() + 1,
            endDate.getHours(),
            endDate.getMinutes()
        );
    }

    // 年跨ぎ補正（12月 → 1月）
    if (startDate.getMonth() === 11 && endDate.getMonth() === 0) {
        endDate = new Date(
            startDate.getFullYear() + 1,
            endDate.getMonth(),
            endDate.getDate(),
            endDate.getHours(),
            endDate.getMinutes()
        );
    }

    // 終了日時が開始日時より後なら同じ抗争
    return endDate.getTime() >= startDate.getTime();
}

/**************************************************
 *  抗争終了判定
 **************************************************/
function checkWarEnd() {
    const raw = document.documentElement.innerHTML;

    // 終了日時を抽出
    const endDate = parseWarEndDate(raw);
    if (!endDate) return; // 終了画面ではない

    // 確定データの開始日時を取得
    const sid = localStorage.getItem(KEYS.ACTIVE_ID);
    if (!sid) return;

    const tid = localStorage.getItem(KEYS.ACTIVE_TID);
    const finalData = localStorage.getItem(`${KEYS.STRATEGY}${tid}_final`);
    if (!finalData) return;

    // セッションIDから開始日時を復元
    const parts = sid.split("_");
    const compact = parts[1]; // MMDDHHmm
    const mm = compact.slice(0, 2);
    const dd = compact.slice(2, 4);
    const HH = compact.slice(4, 6);
    const MM = compact.slice(6, 8);

    const startDate = new Date(
        now().getFullYear(),
        parseInt(mm) - 1,
        parseInt(dd),
        parseInt(HH),
        parseInt(MM)
    );

    // 同じ抗争かどうか判定
    if (!isSameWarSession(startDate, endDate)) {
        return; // 別抗争の終了画面 → 無視
    }

    /**************************************************
     *  抗争終了確定
     **************************************************/
    pushWarLog("INFO", {
        res: "抗争終了を検知（確定）",
        end: endDate.toLocaleString()
    });

    // 攻撃スクリプト停止フラグ
    localStorage.setItem(KEYS.ATTACK_KILL, sid);

    // 状態初期化（次の抗争に備える）
    isEnteringWar = false;
    isFinalScanning = false;
    isPreScanning = false;
    finalScanTimer = null;
    warEntryTimer = null;

    pushWarLog("INFO", { res: "攻撃スクリプト停止指示 → 状態初期化完了" });
}